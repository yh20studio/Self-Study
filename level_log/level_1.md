## 레벨 1과 TDD

레벨 1을 통해서 가장 많이 연습하고 이전과 달라진 점을 뽑자면 테스트 코드 작성입니다. 
처음에는 어려웠지만 미션을 진행하면서 TDD에 학습 내용과 느낀 점을 정리해보려 합니다.

## TDD 학습 내용

### 1. 테스트 코드의 표현

``` java
@Test
void movePieceToAllyExceptionTest() {
    // 영어로 테스트 시나리오와 예상되는 결과를 표기   
}

@SuppressWarnings("NonAsciiCharacters")
@Test
void 같은_팀_기물_위치로_기물을_옮겼을_때_예외_테스트() {
    // 한글로 표기하고 @SuppressWarnings로 경고 제어 
}

@Test
@DisplayName("같은 팀 기물 위치로 기물을 옮겼을 때 예외 테스트")
void moveExceptionTest() {
    // 영어로 테스트 명을 표기하고, 
    // @DisplayName을 통해서 한글로 자세한 시나리오를 표현
}
```

---

### 2. 다양한 테스트 방법

- 반복되는 테스트 코드가 있다면 `@ParameterizedTest`를 사용하여 코드의 반복을 줄인다.

- `assertThatThrownBy()`를 활용해서 예외를 발생하는 코드를 테스트할 수 있다. 예외를 테스트할 때는 `isInstanceOf(), hasMessageContaining()`를 활용해서 더 정확한 검증을 하도록 한다.

- 만약 `assert` 메서드가 여러 개가 반복된다면 `assertAll`을 활용한다.

---

### 3. 테스트 Fixture

테스트 코드를 작성하다 보면 여러 곳에서 자주 사용되는 객체들이 있다. 예를 들면 블랙잭 게임에서 카드, 혹은 체스 게임에서 기물 객체는 테스트에서 자주 사용된다.

이런 코드를 매번 작성하는 것보다 객체들을 정적팩토리 메서드를 통해 생성할 수 있도록 테스트 Fixture로 따로 관리해주는 것이 좋다.

---

### 4. 인터페이스와 의존성 주입을 통한 테스트

	- 블랙잭 미션에서 딜러와 플레이어의 승부 메서드
    - 체스 미션의 폰의 공격 움직임 메서드


이처럼 테스트하기 위해서 충족이 되어야 하는 카드와 체스판의 상태들이 존재하는 메서드들은 테스트하기 어렵다. 이를 해결하기 위한 방법으로 내부에서 값을 생성하지 않고 의존성을 주입하여 원하는 상태에서 테스트를 진행할 수 있도록 한다.


	- 자동차, 로또 미션의 Random을 사용하는 메서드
	- 체스 미션의 DB와 연동되는 Service 내부 메서드


테스트하기 위해서 외부의 값, 혹은 구현에 의존할 수밖에 없는 메서드들은 인터페이스를 이용한 가짜 구현체를 주입하여 테스트를 용이하게 한다.

---

### 5. 테스트 코드도 리팩토링 대상이다.

- assertj에서 제공하는 알맞은 메서드를 사용하여 가독성 높인다.
- 한 테스트에는 한 가지 검증만 하는 것이 좋다.
- 프로덕션 코드와 마찬가지로 메서드의 길이와 indent에 신경 쓴다.

---

### 6. TDD에서 주의할 점

- 테스트 커버리지가 높다고 해서 모든 버그를 방지 하는 것은 아니다.
- TDD는 설계를 위한 방법이 아니기 때문에 시작 전에 설계를 미리 하고 시작 하는 것이 좋다.
